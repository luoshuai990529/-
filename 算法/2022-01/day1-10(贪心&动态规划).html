<!--
 * @Date: 2022-01-10 22:45:22
 * @LastEditors: Lewis
 * @LastEditTime: 2022-01-10 23:46:36
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* 
            给定一个整数数组，判断是否存在重复元素。
            如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

            输入: [1,2,3,1]
            输出: true

            输入: [1,2,3,4]
            输出: false

            输入: [1,1,1,3,3,4,3,2,4,2]
            输出: true
        
         */

      /**
       * @param {number[]} nums
       * @return {boolean}
       */
      var containsDuplicate = function (nums) {
        // 思路一：排序之后再判断相邻两个元素直接有无一样的值，有则返回true，没有则返回false, 时间复杂度：O(NlogN) 空间复杂度：O(logN)
        // const sortList = nums.sort((a,b)=>a-b)
        // for (let i = 0; i < sortList.length; i++) {
        //     if(sortList[i]===sortList[i+1]){
        //         return true
        //     }
        // }
        // return false

        // 思路二：哈希表 时间/空间复杂度：O(N)
        const set = new Set();
        for (const s of nums) {
          console.log("s-", s, set.has(s));
          if (set.has(s)) {
            return true;
          }
          set.add(s);
        }
        return false;
      };
      const nums = [1, 2, 3, 1];
      // console.log("containsDuplicate()-", containsDuplicate(nums));

      /* 
        给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
        子数组 是数组中的一个连续部分。
        链接：https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/

        输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
        输出：6
        解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

        输入：nums = [1]
        输出：1

        输入：nums = [5,4,-1,7,8]
        输出：23
      */

      /**
       * @param {number[]} nums
       * @return {number}
       */
      var maxSubArray = function (nums) {
        // 思路一：贪心算法 时间复杂度 O(N)只遍历一次数组  空间复杂度 O(1)
        // 若当前指针所指的元素之前的和小于0，则丢弃当前元素之前的数列
        let curSum = nums[0]; // 当前和
        let maxSum = nums[0]; // 最大和
        for (let i = 1; i < nums.length; i++) {
          console.log("之前和", curSum);
          curSum = Math.max(nums[i], curSum + nums[i]); // 当前和 = Math.max(当前值, 当前和 + 当前值)
          maxSum = Math.max(curSum, maxSum); // 最大和 = Math.max(当前和，最大和)
          console.log("当前和", curSum);
          console.log("最大和", maxSum);
          console.log("----------------------------");
        }
        return maxSum;
      };

      const list = [5, 4, -1, 7, 8];
      console.log("maxSubArray-00", maxSubArray(list));
      // 思路二：动态规划 ...
    </script>
  </body>
</html>
