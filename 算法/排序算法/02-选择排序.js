/*
 * @Date: 2022-01-28 19:50:49
 * @LastEditors: Lewis
 * @LastEditTime: 2022-01-28 23:49:18
 */

/* 

    选择排序:
        1.双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位（即相当于第一个数字站在擂台上进行比较，每一轮擂台结束都会找到一个最小的数）。
        2.优化：二元选择排序，每轮选择时记录最小值和最大值，可以把数组需要遍历的范围缩小一倍。
    和冒泡排序对比
        相同点：
            时间复杂度：O(n^2)
            空间复杂度：O(1)
        不同点：
            1.冒泡排序在比较过程中就不断交换；而选择排序增加了一个变量保存最小值/最大值的下标，遍历完后才交换，减少交换的次数
            2.冒泡排序是稳定的，而选择排序是不稳定的。
    
    什么是排序算法的稳定性：
        假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，
        即在原序列中，r[i] = r[j],且r[i]在r[j]之前，而排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是否稳定，否则称为不稳定
    
    理解了稳定性之后，我们就可以分析出，冒泡排序中，只有左边的数字大于右边的数字才会发生交换，相等的数字之间不会发生交换，因此他是稳定的。
    而选择排序中，最小值和首位交换的过程可能会破坏稳定性，比如数列：[2,2,1],在选择排序的第一次进行交换时，原数列中的两个2的相对顺序就发生了改变，因此它是不稳定的。

    那么排序算法有什么意义呢，其实它只在一种情况下有意义：
        当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。
        例：如果我们需要对一组商品进行排序，商品存在的两个属性：价格和销量。当我们按照价格从高到低排序后，要再按照销量对其排序，这时，
        如果要保证销量相同的商品仍然保持价格从高到低的顺序，就必须使用稳定性算法。

        注意：当然算法的稳定性与具体的实现有关。在修改比较条件后，稳定性的排序算法可能变成不稳定。如冒泡算法中
        将【左边的数大于右边的数，则交换】这个条件修改位【左边的数大于或等于右边的数，则交换】，冒泡算法就变得不稳定了。


    */

const selectionSort1 = (arr) => {
    let minIndex;
    for (let i = 0; i < arr.length - 1; i++) {
        minIndex = i;
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[minIndex] > arr[j]) {
                // 记录最小值的下标
                minIndex = j;
            }
        }

        // 将最小元素交换至首位
        const temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
};
let list1 = [1, 2, 3, 4, 6, 5, 7, 8];
selectionSort1(list1);
console.log("result--", JSON.stringify(list1));

const selectionSort2 = (arr) => {
    let minIndex, maxIndex;

    for (let i = 0; i < arr.length / 2; i++) {
        minIndex = i;
        maxIndex = i;
        for (let j = i + 1; j < arr.length - i; j++) {
            if (arr[minIndex] > arr[j]) {
                // 记录最小值的下标
                minIndex = j;
            }
            if (arr[maxIndex] < arr[j]) {
                // 记录最大值的下标
                maxIndex = j;
            }
        }

        // 如果 minIndex和 maxIndex都相等，那么它们都必定等于i，且后面的所有数字都与arr[i]相等，此时排序完成
        if (minIndex === maxIndex) break;

        // 将最小元素交换至首位
        let temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;

        // 如果最大值的下标刚好是i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新maxIndex的值
        if (maxIndex === i) maxIndex = minIndex;
        // 将最大元素交换至末尾
        const lastIndex = arr.length - 1 - i;
        temp = arr[lastIndex];
        arr[lastIndex] = arr[maxIndex];
        arr[maxIndex] = temp;
    }

    /* 
        小结：
            我们使用minIndex和maxIndex来记录最小和最大值的下标。
            每次遍历后，将最小值交换到首位，最大值交换到末尾，就完成了排序
            由于每一轮遍历可以排好两个数字，所以最外层的遍历只需要遍历一半即可。
            二元选择排序中有一句很重要的代码，它位于 交换最小值 和交换最大值 的代码中间： if (maxIndex == i) maxIndex = minIndex;
            这行代码的作用处理了一种特殊情况：如果最大值的下标等于i，也就是说 arr[i] 就是最大值，由于 arr[i] 是当前遍历轮次的首位，
            它已经和arr[minIndex] 交换了，所以最大值的下标需要跟踪到arr[i] 最新的下标minIndex
    */
};
let list2 = [1, 2, 3, 4, 6, 5, 7, 8];
selectionSort2(list2);
console.log("result--", JSON.stringify(list2));


/* 
    总结：
        通过实例测试看看效率到底提升了多少：

        数组长度    排序算法    i的比较次数     j的比较次数     数组元素的比较次数      总比较次数
        10         选择排序       10             54                45                  109
        10         二元选择排序    6             30                50                   86
        100        选择排序       100           5049              4950                10099
        100        二元选择排序    51            2550             5000                 7601
        1000       选择排序       1000          500499           499500              1000999
        1000       二元选择排序    501          250500           500000               751001     

    通过上述对比，我们可以发现二元选择排序中的arr数组比较次数甚至略高于选择排序的次数，整体是相差无几的。
    只是i和j的比较次数较少，就是这两个地方提高了效率。
    并且在二元选择排序中，可以做一个剪枝优化，当minIndex和maxIndex相等时 说明后续所有的元素都相等，就如同
    班上最高的学生和最矮的学生一样高，就说明了班上人的身高都相同了。

    注意：二元选择排序同样也是不稳定的

    时间复杂度&空间复杂度
        选择排序使用了两层循环，时间复杂度是O(n^2);空间复杂度位O(1)。
        二元选择排序虽然比选择排序要快，但是治标不治本，无法优化其时间复杂度。
*/
