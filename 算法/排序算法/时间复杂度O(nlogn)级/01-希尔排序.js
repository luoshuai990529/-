/*
 * @Date: 2022-01-30 12:42:25
 * @LastEditors: Lewis
 * @LastEditTime: 2022-01-30 14:52:13
 */

/* 
    1957年，美国数学博士Donald Shell发表了希尔排序算法，成为首批将时间复杂度降到 O(n^2) 以下的算法之一。
    虽然原始的希尔排序最坏时间复杂度仍然是 O(n^2), 但经过优化的希尔排序可以达到O(n^1.3) 甚至 O(n^ 7/6)

    略为遗憾的是，希尔、冒泡、选择、插入排序都逐渐被快速排序所淘汰，但是作为承上启下的算法，依然值得我们学习

    希尔排序本质上是对插入排序的一种优化，它利用插入排序的简单，又克服了插入排序每次只交换相邻两个元素的缺点。
    它的基本思想：
        1.将待排序数组按照一定的时间间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是连续
        的一段数组，而是每跳跃一定间隔取一个值组成一组。
        2.逐渐缩小间隔进行下一轮排序
        3.最后一轮时，取间隔为1，也就相当于直接使用插入排序。但这时经过前面的【宏观调控】，数组已经基本有序了，
        所以此时的插入排序只需要进行少量交换便可以完成。

    举个例子，对数组[84,83,88,87,61,50,70,60,80,99] 进行希尔排序的过程如下：

        1.第一遍（5间隔排序）：按照间隔5分割子数组，共分成五组，分别是：
                [84,50],[83,70],[88,60],[87,80],[61,99]
            对他们进行插入排序，排序后变成了：
                [50,84],[70,83],[60,88],[80,87],[61,99]
            此时整个数组变成了：
                [50,70,60,80,61,84,83,88,87,99]
                
        2.第二遍（2间隔排序）：按照间隔2分割子数组，共分成两组，分别是：
                [50,60,61,83,87],[70,80,84,88,99]
            对他们进行插入排序，排序后他们分别变成：
                [50,60,61,83,87],[70,80,84,88,99]
            此时整个数组变成了
                [50,70,60,80,61,84,83,88,87,99]

            这里有一个非常重要的性质:当我们完成了2间隔排序后，这个数组仍然是保持5间隔有序的。
            也就是说：更小间隔的排序没有把上一步的结果变坏。

        3.第三遍（1间隔排序，等于直接插入排序）：按照间隔1分割子数组，分成一组，也就是整个数组。
        对其进行插入排序，经过两遍排序，数组已经基本有序，所以这一步只需要经过少量的交换既可以完成排序，排序后数组变成：
            [50,60,61,70,80,83,84,87,88,99]

*/

const shellSort = (arr) => {
    // 间隔序列，在希尔排序中我们称之为增量序列
    for (let gap = arr.length / 2; gap > 0; gap = parseInt(gap/2)) {
        // console.log(gap) // 增量序列： 5 2 1 注意：增量序列的选择会极大地影响希尔排序的效率。
        // 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组
        for (let i = gap; i < arr.length; i++) {
            // currentNumber 站起来，开始找位置
            const currentNumber = arr[i];
            // 该组前一个数组的索引
            let preIndex = i - gap;
            while (preIndex >= 0 && currentNumber < arr[preIndex]) {
                // 向后挪位置
                arr[preIndex + gap] = arr[preIndex];
                preIndex -= gap;
            }
            // currentNumber 找到了自己的位置 坐下
            arr[preIndex + gap] = currentNumber;
        }
    }
};
const list = [84, 83, 88, 87, 61, 50, 70, 60, 80, 99];
shellSort(list)
console.log("result-", JSON.stringify(list));

/* 
    小结：
        上面这段代码和插入排序非常相似，区别仅在于希尔排序最外层嵌套了一个缩小增量的for循环；
    并且插入时不再是相邻数组挪动，而是增量为步长挪动。

    增量序列的选择会极大的影响希尔排序的效率。增量序列如果选的不好，希尔排序的效率可能比插入排序效率还低

    虽然插入排序是稳定的排序算法，但希尔排序是不稳定的。在增量较大时，排序过程可能会破坏原有数组中相同关键字的相对次序。

    时间复杂度&空间复杂度：
    事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 O(n) 到 O(n^2) 之间，普遍认为它最好的时间复杂度为 O(n^1.3)。
    希尔排序的空间复杂度为 O(1)O(1)，只需要常数级的临时变量。

    相对于前面介绍的冒泡排序、选择排序、插入排序来说，希尔排序的排序过程显得较为复杂，希望读者还没有被绕晕（PS：😵其实我已经晕了，我这里也是抱着了解一下的心态来学习希尔排序的）。

    问题：那么希尔排序凭什么可以打破时间复杂度O(n^2)的魔咒呢?它和之前排序算法的区别是什么？
    解释：
        这个问题我们可以用逆序来理解，当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，
    则这两个数字组成一个逆序对。
    
    排序算法本质上就是一个消除逆序对的过程。

    对于随机数组，逆序对的数量是O(n^2)级的，如果采用「交换相邻元素」的办法来消除逆序对，每次最多只能消
    除一组逆序对，因此必须执行 O(n^2) 级的交换次数，这就是为什么冒泡、插入、选择算法只能到 O(n^2)级的原
    因。反过来说，基于交换元素的排序算法要想突破O(n^2)级，必须通过一些比较，交换间隔比较远的元素，使得
    一次交换能消除一个以上的逆序对。

    我认为最后最重点一的句话：希尔排序在面试或是实际应用中都很少遇到，读者仅需了解即可。 滑稽😆😆😆
    */