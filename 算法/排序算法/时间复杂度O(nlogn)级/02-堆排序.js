/*
 * @Date: 2022-01-30 14:53:02
 * @LastEditors: Lewis
 * @LastEditTime: 2022-01-30 19:22:07
 */

/* 
    数组、链表都是一维的数据结构，相对来说比较容易理解，而堆是二维的数据结构，对抽象思维的要求更高，
    所以许多程序员【谈堆变色】，但堆又是数据结构进阶的必经一步，我们可以将其梳理清楚

    堆：符合以下两个条件之一的完全二叉树：
        1.根节点的值 >= 子节点的值，这样的堆被称之为最大堆，或大顶堆；
        2.根节点的值 <= 子节点的值，这样的堆被称之为最小堆，或小顶堆。

    堆排序的过程如下：
        1.用数列构建出一个大顶堆，取出堆顶的数字；
        2.调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字；
        3.循环往复，完成整个排序

    构建大顶堆&调整堆
        方案一：从 0 开始，将每个数字依次插入堆中，一边插入，一边调整堆结构，使其满足大顶堆的要求；
        方案二(常用)：将整个数列的初始状态视作一颗完全二叉树，自底向上调整树结构，使其满足大顶堆的要求；
    
    动图演示：
        初始化堆：![](https://lewis-note.oss-cn-beijing.aliyuncs.com/github/initdui.gif)
        排序过程：![](https://lewis-note.oss-cn-beijing.aliyuncs.com/github/tiaozhengdui.gif)

    在介绍堆排序的具体实现之前，我们需要了解完全二叉树的几个性质。将根节点的下标视为0，则完全二叉树有如下性质：
        1.对于完全二叉树中的第i个数，它的左子节点下标： left = 2i + 1
        2.对于完全二叉树中的第i个数，它的右子节点下标： right = left + 1
        3.对于有n个元素的完全二叉树(n >=2 )，它的最后一个非叶子节点的下标： n/2 - 1 

    
*/
const { swap } = require("./swap");

function heapSort(arr) {
    console.log("原列表结构：", JSON.stringify(arr));
    // 1-构建初始大顶堆
    buildMaxHeap(arr);
    console.log("构建好的堆结构：", JSON.stringify(arr));
    // 2-开始堆排序
    for (let i = arr.length - 1; i > 0; i--) {
        // 将最大值交换到数组最后
        swap(arr, 0, i);
        // 调整剩余数组，使其满足大顶堆
        maxHeapify(arr, 0, i);
    }

    /* 
        堆排序的第一步就是构建大顶堆：
            将数组视作一颗完全二叉树，从它的最后一个非叶子结点开始，调整此结点和其左右子树，使这三个数字构成一个大顶堆。
        调整过程由maxHeapify 函数处理：
            此函数记录了最大值的下标，根节点和其左右子节点在经过比较之后，将最大值交换到根节点位置。这样三个数字就构成了一个大顶堆。
            
        需要注意的是：如果根节点和左右子树节点任何一个数字发生了交换，则还需要保证调整后的子树仍然是大顶堆，所以子树会执行一个递归的调整过程。

        这里的递归比较难以理解，打个比方：
            构建大顶堆的过程就是一堆数字比赛谁更大。比赛过程分为初赛、复赛、决赛，每场比赛都是三人参加。
            但不是所有人都会参加初赛，只有叶子节点和第一批非叶子节点会进行三人组初赛。
            初赛的冠军站到三人组的根节点位置，然后继续参加后面的复赛。

            而有的人生来就在上层，如 节点A 一开始就是二叉树的根节点，当其他节点进行初赛、复赛时，他就静静的在根节点位置等决赛。
            等其他节点 B 和 C 经过重重比拼来到根节点的左右树子节点的位置。他们三人开始决赛，通过比较可以选出最强的一个节点即最大值节点。
            但是如果 节点A 这时候输给了其中任何一个节点，比如输给了 节点B ，那么 B节点 和 C节点将继续对比，选出本次构建大顶堆的冠军。
            但是此时 节点A 也不能坐享其成获得第三名，它需要从B节点的打拼路线继续向下比较比回去，找到自己真正实力的位置。
            这就是maxHeapify 中会继续递归调用maxHeapify 的原因。
        
        当构建出大顶堆之后，就要把冠军交换到数列最后，深藏功与名。来到冠军宝座的新节点又要和 A节点 一样，开始向下比较，
        找到自己的真实位置，使得剩下的 n-1 个数字构建成新的大顶堆。这就是heapSort方法的for循环中，调用 maxHeapify的原因。

        变量heapSize 用来记录剩下多少个数字没有排序完成，每当交换了一个堆顶的数字，heapSize就会减1。
        在maxHeapify方法中，使用 heapSize 来限制剩下的选手，不要和已经躺在数组最后，当过冠军的人比较

        以上就是堆排序的思想。学习时我们采用的是最简单的代码实现，在熟练掌握之后我们就可以加入一些小技巧去提高效率。
        如：我们知道计算机采用二进制来存储数据，数字左移一位表示乘以2，右移一位表示除以2。（PS：😲我表示并不知道）
        所以：
            堆排序代码中的arr.length / 2 - 1 可以修改为 (arr.length >> 1) - 1
            左子节点下标 2*i+1 可以修改为 (i << 1) + 1。
        需要注意的是，位运算符的优先级比加减运算的优先级低，所以必须给位运算符加上括号

        注：在有的文章中，作者将堆的根节点下标视为 1，这样做的好处是使得第 i 个节点的左子节点下标为 2i，
        右子节点的下标为 2i+1 ，与 2i+1 和 2i+2 相比，计算量会少一点，但两种实现思路的核心思想都是一致的。
        
    */
}

// 构建初始大顶堆
function buildMaxHeap(arr) {
    // 从最后一个非叶子节点开始调整大顶堆，最后一个非叶子节点的下标就是 arr.length / 2 - 1
    for (let i = parseInt(arr.length / 2) - 1; i >= 0; i--) {
        maxHeapify(arr, i, arr.length);
    }
}

/**
 * @description: 调整大顶堆
 * @param {*} arr
 * @param {*} i
 * @param {*} heapSize 剩余未排序的数字的数量，也就是剩余堆的大小
 * @return {*}
 */
function maxHeapify(arr, i, heapSize) {
    // 左子节点下标
    const left = 2 * i + 1;
    // 右子节点下标
    const right = left + 1;
    // 记录根节点、左子树节点、右子树节点三者中的最大值下标
    let largest = i;
    // 与左子树节点比较
    if (left < heapSize && arr[left] > arr[largest]) {
        largest = left;
    }
    // 与右子树节点比较
    if (right < heapSize && arr[right] > arr[largest]) {
        largest = right;
    }
    console.log(`最大值下标：${largest}, i:${i} 剩余堆大小：${heapSize}`);
    if (largest != i) {
        // 将最大值交换为根节点
        swap(arr, i, largest);
        // 再次调整交换数字后的大顶堆
        maxHeapify(arr, largest, heapSize);
    }
}

// const list = [9, 6, 8, 5, 4];
const list = [ 6, 9, 8, 5, 4];
heapSort(list)
console.log("result---", JSON.stringify(list));

/* 
    小结：
        堆排序分为两个阶段：1-初始化建堆(buildMaxHeap) 2-重建堆(maxHeapify) ，所以时间复杂度要从这俩方面分析
        根据数学运算可以推导出初始化建堆的事件为复杂度为 O(n),重建堆的时间复杂度为O(n log n),
        所以堆排序总的时间复杂度为 O(n log n)。推导过程较为复杂，故不再给出证明过程。

        堆排序的空间复杂度为 O(1),只需要常熟级的临时变量。

        tips:在实际应用中 快速排序性能会优于堆排序。

*/