#### 作用域是什么

`var a = 1` 编译器会做什么处理：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
**作用域是一套规则，用于确定在何处以及如何查找变量（标识符）**。如果查找的目的是对变量进行赋值，那么就会使用 LHS(赋值操作的目标是谁) 查询；如果目的是获取变量的值，就会使用 RHS(谁是赋值操作的源头) 查询。

#### 词法作用域

JavaScript 中有两个机制可以“欺骗”词法作用域：`eval(..) `和 `with`。前者`eval`可以对一段包 含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域。后者`with`本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域。这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。**不要使用它们**。

#### 函数作用域和块级作用域

函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。

#### 提升

我们习惯将 `var a = 2;` 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 `var a` 和` a = 2` 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。
这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的**声明**（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为**提升**。

#### 作用域闭包

**闭包**是基于词法作用域书写代码时所产生的自然结果，我们不需要为了利用它而有意识的创建闭包。闭包的创建和使用在你的代码中随处可见。

```javascript
function wait(message) { 
	setTimeout( function timer() { console.log( message ); }, 1000 ); 
}
wait( "Hello, closure!" );
/**
	wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..) 作用域的闭包。
**/
```

**本质上**无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使 用了回调函数，实际上就是在**使用闭包**！

尽管 **IIFE** 本身并不是观察闭包的恰当例子，但它的确**创建了闭包**，并且也是最常用来创建 可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。 

**小结：当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包**

