# 组件的实现原理

打那个我们编写的代码越来越多，用来描述页面结构的虚拟DOM的代码也会变得越来越多，页面的模板也会变得越来越大。这时我们就需要组件化的能力，有了组件拆分能力我们就可以将其进行拆分解耦。组件化的实现同样需要渲染器的支持。

**问题1：普通标签、Fragment等都可以通过`vnode.type`区分，那么如何区分组件？**

```javascript
// 通过type属性来存储组件的选项对象
const vnode = {
	type: MyComponent
    // ...
}
```

我们可以对组件类型的`vnode`进行区分后，就可以在`patch`补丁函数中判断`vnode.type`来决定调用`mountComponent`和`patchComponent`来完成更新和挂载了。

**问题2：用户如何编写组件？组件的选项对象必须包含什么?**
实际上组件本身是对页面内容的封装，它用来描述页面内容的一部分。因此，一个组件必须包含一个渲染函数，即`render`函数，并且渲染函数的返回值应该是虚拟DOM。例：

```javascript
const MyComponent = {
	name: 'MyComponent',
    data() {
    	return {
        	foo: 'hello world'
        }
    },
	render() {
		// 返回虚拟DOM
		reutrn {
			type: 'div',
			children: 'text 1'
		}
	}
}
```

**问题3：组件如何实现自身状态的初始化和自更新？**
在`mountComponent`函数中挂载组件时，会通过`reactive`函数将data函数返回的状态包装成响应式数据，在调用`render`函数时，将this的指向设置成响应式数据state，同时将其作为`render`函数的第一个参数传递。当组件状态发生变化，我们需要有能力触发组件的自更新，因此会将其渲染任务包装到一个`effect`中。为了减少重复的状态修改操作，还会设计一个异步调度器来通过将任务缓冲到微任务队列中而减小性能开销。

**问题4：组件生命周期的原理如何实现？**
我们可以在需要的时候，任意的在组件实例instance上添加需要的属性，如组件实例中的`isMounted`属性就可以用来区分组件的挂载和更新。因此 我们只需要在合适的时机调用对应的生命周期钩子即可，由于可能存在多个同样的组件生命周期钩子，如来自`mixins`中的生命周期函数，所以我们需要将组件生命周期钩子序列化为一个数组，其核心原理还是不变。

**问题5：Vue中父组件状态的变更引起的更新，子组件会不会被动更新？**
子组件的被动更新由`patchComponent`函数来完成，当子组件更新时我们需要：1-检测子组件是否真的需要更新，因为子组件的`props`可能是不变的；2-如果需要更新，则更新子组件的`props、slots`等内容；

**问题6：当用`this`读取数据时如果`props、data`中有同样的数据会如何读取？**
每当在渲染函数或者声明周期钩子中通过`this`来读取数据时，都会优先从组件的自身状态中读取，如果组件本身没有对应的数据则再从`proops`数据中读取。

**问题7：插槽的工作原理**
在编译组件模板时会先将插槽编译成**插槽函数`this.$slots.xxx()`**，这个函数的返回值就是具体的插槽内容。渲染函数`render`的返回值中就会编译为`{type: 'header', children: [this.$slots.xxx]}`。渲染插槽内容的过程就是调用插槽函数并渲染由其返回的内容的过程。

**问题8：Vue3中的`onMounted`函数为什么可以多次调用注册多个钩子函数并且可以在不同的组件实例中调用时绑定到对应的组件实例上去的呢？**
有A和B两个组件，在其组件的`setup`函数中调用`onMounted`注册钩子函数都会绑定到对应的组件A和B上，实现这个我们只需要维护一个变量`currentInstance`，用其来存储当前的组件实例，每当初始化组件并执行组件的`setup`函数之前，将其变量设置为当前的组件实例，再执行组件的`setup`函数，就可以将其`onmounted`所注册的钩子与对应的组件实例绑定上了。而多次调用`onMounted`钩子注册函数，我们只需要在组件实例的`instance`对象上设计`mounted`数组将注册的钩子函数都依次添加到其数组中，然后在合适的时机去遍历该数组即可完成了。

**问题9：什么是异步组件？它的原理是什么？**
异步组件：以异步的方式加载并渲染一个组件，它在代码分割、服务端下发组件等场景尤为重要。它的本质是通过粉装手段来实现友好的用户接口，从而降低用户层面的使用复杂度：如我们通过调用`defineAsyncComponent`函数来创建组件:`defineAsyncComponent(() => import('CompA'))`;这个函数本质是一个高阶组件，它的返回值是一个包装组件。包装组件会根据加载器的状态来选择渲染什么内容。

**问题10：KeepAlive组件的实现原理?**
`KeepAlive`一词借鉴于HTTP协议。在HTTP协议中，它又称之为**HTTP持久连接**，其作用是允许多个请求或者响应共用一个TCP链接。`KeepAlive`组件的实现需要渲染器层面的支持，当其被卸载时，我们不能真的将它卸载，而是将其组件从原容器搬运到另一个隐藏的容器中，实现“假卸载”。当被搬运到隐藏容器中的组件需要再次被“挂载”时，我们只需要将其再搬回到原容器中，这个过程就是`activated`和`deactivated`；它和普通组件的较大区别是它和渲染器的结合很深，它的渲染函数最终只返回其“内部组件”，在其内部会对“内部组件”vnode对象上添加一些标记属性，用于执行特定逻辑，如：

- `shouldKeepAlive`：通过这个属性知道“内部组件”是否需要被KeepAlive，这样在卸载时就不会真的卸载而是调用`_deActivate`完成搬运工作。
- `keepAliveInstance`：KeepAlive组件实例，是给内部组件调用实例上方法时用的。如：通过其实例对象分别调用`_activate`和`_deActivate`激活和隐藏组件。
- `keptAlive`：“内部组件”如果已经被缓存，则就会有这个标记，当其需要重新渲染时 不是去执行挂载操作，而是将其进行激活即可。

默认情况下，它会对所有“内部组件”进行缓存，因为有时候用户并不希望这样因此有了`exclude`和`include`两个选项来进行自定义缓存规则哪些被缓存和不被缓存。
**如何进行缓存管理呢？**用一个`Map`对象来实现对组件的缓存：对象的**键**是组件选项对象，即`vnode.type`属性的值,对象的**值**是用于描述组件的`vnode`对象(因为其存在对组件实例的引用，所以也相当于缓存了组件实例)。
**当缓存数量超过指定阈值需要对其修剪，那么我们应该以怎样的策略进行修剪呢？**采用“最新一次访问”策略，首先我们需要设置最大缓存容量`max`属性。当其值超过了这个容量就要根据该策略进行修剪，其核心是：需要把当前访问的组件作为最新一次渲染的组件，并且该组件在缓存修剪过程中始终是安全的，即不会被修剪。这里的策略也可以参照LRU（最近最少使用原则）。

**问题11：Teleport组件的实现原理？**
当我们封装一个`<modal />`弹窗组件时想要将其挂载到指定的节点中时，在Vue2中我们只能够通过原生`DOM API`来手动搬运Dom元素实现需求，为了让其和Vue.js的渲染机制一致，于是出现了`<Teleport>`内建组件，可以让其将指定的内容渲染到特定的容器中不受DOM层级的限制。和React中的`Portals`方案相似。
例：`<Teleport to="body"><div class='modal'>我是弹窗</div></Teleport>`
为了将`Teleport`组件的渲染逻辑从渲染器中分离出来，也要修改`patch`函数，通过组件选项的`_isTeleport`标识来判断组件是否是**Teleport**组件，如果是，则直接调用组件选项中定义的`process`函数将渲染控制权交接出去。`process(n1, n2, container, anchor, internals)`函数接收五个参数,渲染思路和渲染器本身保持一致，通过判断旧节点n1是否存在来执行挂载还是更新操作。如果是挂载，则根据**`props.to`**属性通过`querySelector`取得真的挂载点，再遍历`Teleport`组件的`children`属性，逐一调用`patch`函数完成子节点的挂载。更新的话则调用`patchChildren`即可，再判断新旧`to`的属性值是否一致，不一致则移动内容。

**问题12：Transition组件的实现原理：**

核心原理：

- 当DOM元素被挂载时，将动效附加到该DOM元素上；
- 当DOM元素被卸载时，不要立即卸载DOM元素，而是等到附加到该DOM元素上的动效执行完成后再卸载它。

原生DOM的过渡原理：

![image-20230222210132219](https://lewis-note.oss-cn-beijing.aliyuncs.com/github/image-20230222210132219.png)

以上就是进场过度动画的实现原理，其中通过嵌套`requestAnimationFrame`解决了动画不执行和浏览器bug的问题。
卸载时我们也不能马上将DOM元素卸载，我们需要等到过渡动画结束后再执行，所以将卸载操作封装到`performRemove`函数中，监听`transitionend`事件,例：

```javascript
el.addEventListener('transitionend', () => { 
	// remove class code...
	performRemove();
})
```

`Transition`组件的实现原理和为原生DOM添加过渡效果的原理类似，我们需要将过渡相关的钩子函数定义到虚拟节点的`vnode.transition`对象中。渲染器在执行挂载和卸载操作时，会优先检查该虚拟节点是否需要进行过渡，如果需要，则会在合适的时机执行`vnode.transition`对象中定义过渡相关的钩子函数。





