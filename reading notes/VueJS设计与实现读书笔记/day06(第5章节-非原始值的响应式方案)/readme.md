# 非原始值的响应式方案(代理异质对象、数组、Map、Set)

小结：

​	实际上，实现响应式数据要比我们想象中难很多，它并不是像上一章讲述的那样，单纯的拦截 get/set 操作即可。比如：如何拦截`for...in`循环？track函数如何追踪拦截到的`for...in`循环？类似的问题很多。除此之外我们还要考虑如何对数组进行代理。Vue.js3中还支持集合类型：`Map`、`Set`、`WeakMap`和`WeakSet`等。此章节将会揭晓答案。

​	1.理解`Proxy` 和 `Reflect`: **`Proxy`**可以创建一个代理对象。能够实现对**其他对象**的代理,也就是说，**Proxy只能代理对象，无法代理非对象值，如字符串、布尔值等**。 所谓代理，指的是对一个对象**基本语义**的代理。什么是基本语义：**给出一个对象`obj`可以对它进行一些操作，如读取、设置属性值，就属于基本语义的操作**。`Reflect`是一个全局对象，它下面的方法和`Proxy`的拦截器方法名相同，即任何在`Proxy`下能找到的方法都能够在`Reflect`中找到同名函数。 那么**`Reflect`所存在的意义其实是因为`Reflect`下的方法还能够接收第三个参数，即指定接受者receiver, 可以理解为函数调用过程中的this。** 而在我们实现代理的过程中会遇到访问器属性的`this`指向问题，我们就需要通过`Reflect`下的方法来指定正确的receiver来解决其问题。

​	2.接着讨论了JavaScript中对象的概念，以及Proxy的工作原理。根据ECMAScript规范，在JavaScript中有两种对象，一种叫 **常规对象**，另一种叫**异质对象** ，而我们来区分它们就是通过**对象的内部方法**是否符合其规范所给出的定义实现。一个对象所必要的内部方法这里作者也列出来了可以到 [摘自 ECMAScript 2022 Language Specification 的 Invariants of the Essential Internal Methods ](https://262.ecma-international.org/13.0/#sec-ecmascript-data-types-and-values) 找到其描述，除此之外还有两个额外的内部方法：[ Call 和 Construct ](https://262.ecma-international.org/13.0/#sec-ecmascript-data-types-and-values) 需要按照规范中的定义实现。满足了以上几点它就是一个常规对象，而不符合这几点要求的那么它就是一个异质对象。例如由于`Proxy`对象的内部方法 [[Get]] 没有使用ECMA规范的定义实现，因此**`Proxy` 也是一个异质对象**。而接着又提到了**一个对象它是其他对象还是函数，其实是由部署在该对象上的内部方法和内部槽所决定的。** 在代理Object对象中先是提到了对 `in` 操作符的拦截，我们先通过查找其ECMA规范中定义的运行时执行逻辑能找到其结果是在哪个内部方法中返回的，然后通过查规范表来找到我们可以通过`has` 拦截函数来实现对`in`操作符的代理。 接着讨论如何拦截`for...in`循环，这里在使用`track`函数进行追踪的时候，我们构建了唯一的key作为标识，即**ITERATE_KEY**, 是因为`onwKeys`拦截函数与`get/set`的不同。在`trigger`触发其关联的副作用函数时也通过一个`type`标识来判断此次操作是添加属性还是设置原有的属性，从而避免了不必要的性能开销 。其**代理对象的本质都是通过查阅规范并找到可以拦截的基本操作的方法。有一些操作并不是基本操作，而是复合操作，这就需要我们查阅规范了解其依赖哪些基本操作，从而通过基本操作的拦截间接的去处理复合操作。** 
​	再是讨论了**如何合理地触发副作用函数的重新执行**，包括对**`NaN问题`**的处理，以及**访问原型链上继承属性的情况导致副作用函数重新执行两次**的问题。对于处理`NaN`我们需要**注意`NaN === NaN` 永远都是false，这时如果响应式对象的初始值是`NaN`后续又为其设置了`NaN`作为新值，此时用全等于比较的话仍然会触发响应，这是不必要的；因此我们判断新值旧值不全等的情况下还要再判断他们都不是`NaN`就解决了这个问题。**
​	**对于原型链的问题：定义空对象`a`和对象`b`并为他们创建对应的响应式对象`child`和`parent`，并使用了`setPrototypeOf`将`parent`设置为`child`的原型,此时我们在副作用函数内访问`child.val`时，值是从原型上继承而来的，此时我们执行`child.val = xx`时期望副作用函数执行，但是这时你会发现它不仅执行了，还执行了两次，这就造成了不必要的更新。解决这个问题我们需要查找规范中的定义，根据定义我们屏蔽了由原型引起的更新，并解决了这个问题**。在这里作者还封装了一个**`reactive函数`：对Proxy的一层封装，它接收一个对象作为参数，并返回为其创建的响应式数据。**

​	3.**浅响应和深响应：**即`reactive`和`shallowReactive`的区别，有的时候我们并非所有的情况都希望深响应，因为给一些数据量大且深层的对象做深响应也意味着更多的性能开销，所以催生了`shallowReactive`，它所创建的代理对象只有对象的第一层是响应的。**只读和浅只读：** `readonly`和`shallowReadonly`,在实现过程的同时还提到了只读的属性是不需要调用`track`函数追踪响应的。

​	4.**代理数组：** 数组是一个**异质对象**， 因为其对象部署的内部方法`[[DefineOwnProperty]]`不同于常规对象。通过索引为数组设置新的元素，可能会隐式的改变数组`length`属性的值。而对应修改其`length`值，也可能会间接的影响数组中的已有元素（**本质都是修改了数组的length属性**）。所以在触发响应的时候需要额外注意。接着讨论了如何拦截 `for...in` 和 `for...of` 对数组的遍历：`for...in` 循环遍历数组和遍历普通对象差别不大，需要注意的是**我们在追踪`for...in`时需要使用数组的length作为追踪的key**。这里还提到了`for...of`是用来遍历可迭代对象的，那么什么是可**迭代对象**：ES2015给JavaScript定义了**迭代协议**：**一个对象能否被迭代，取决于该对象或者该对象的原型是否实现了`@@iterator`方法。这里的`@@[name]`标志在ECMAScript规范里用来代指JavaScript内建的symbols值，如`@@iterator`就是指`Symbol.iterator`这个值。如果一个对象实现了`Symbol.iterator`方法，那么这个对象就是可迭代的。**接着通过了解规范中定义的数组迭代器的执行流程，我们可以知道数组迭代器的执行会读取数组的length属性，我们在迭代数组时只需要在副作用函数和数组的长度和索引之间简历响应联系，就可以实现对`for...of`的拦截。需要注意的是使用`for...of`循环会读取数组的`Symbol.iterator`属性，因为这个属性是一个`symbol`值，**为了避免意外的错误和对性能的考虑，我们要避免副作用函数和这类`symbol`值之间建立响应式联系**，即在`get`方法调用`track`时要注意 key的类型是否是`symbol`即可。 

​	5.**数组的查找方法：**`includes、indexOf...` 我们通过查阅规范找到其方法的执行流程，会发现执行这些函数时会有this指向的问题。因为用户既可能使用原始对象进行查找，也可能使用代理对象进行查找，为了支持这两种作者会重写数组的`includes、indexOf、lastIndexOf` 方法将其封装到`arrayInstrumentations`对象中，**原理就是当用户使用这些方法进行查找元素时，会先去代理对象中查找，如果找不到，再去原始数组中查找。**

​	6.**隐式修改数组长度的原型方法：**`push、pop、shift、unshift、splice`,因为调用其方法**即会读取数组的length属性，又会设置数组的length属性**。就导致了两个独立副作用函数互相影响，从而运行时会导致**栈溢出**的错误。解决思路就是“屏蔽”对length属性的读取，避免在它和副作用函数之间建立响应式联系，问题就解决了，因为数组的`push`方法其实在语义上就是修改操作，而非读取操作，因此这个思路是对的，接着通过重写`push`方法来实现了这个。**通过定义一个标记变量`shouldTrack` ，代表是否允许追踪，在`track`函数中只有当此标记为true是才进行追踪**

​	7.**代理Map和Set集合类型的数据:** 整体思路依旧是：读取操作调用`track`建立响应联系，设置操作时调用`trigger`触发响应。需要注意的是集合类型不同于普通对象，它有特定的数据操作方法，如集合类型的`size`属性是一个访问器属性，当代理对象访问`size`属性时，由于代理对象本身并没有部署`[[SetData]]`这样的内部槽，因此会发生错误。同时我们需要注意这些方法执行时的this指向，我们需要在get拦截时通过`.bind`来重新为此绑定正确的this指向。然后还讨论了集合类型响应式数据的实现。需要通过“重写”集合的方法来实现自定义的能力，将重写的方法添加到`mutableInstrumentations`对象中。再讨论了“数据污染”的问题，什么是数据污染：**不小心将响应式数据添加到原始数据中，它导致了用户可以通过原始数据执行响应式相关的操作**，为了避免这个问题我们通过响应式数据对象的`raw` 属性来访问对应的原始数据对象，后续操作使用原始数据对象就可以了。接着讨论了集合类型的遍历，即`forEach`方法，对比对象的`for...in`遍历，不同的是`for...in`遍历对象时，我们只关心对象的键是否变化，而不关心值；但是使用`forEach`时我们即关心键的变化又关心值的变化。这里在处理迭代器方法时，还讲解了响应式Map对象的**`entries`的返回值不是一个可迭代对象 **，它的返回值是一个对象并带有`next`方法，但是它不具备`Symbol.iterator`方法，因此它不是一个可迭代对象。这里不要把可迭代协议和迭代器协议搞混。**可迭代协议**：对象实现了`Symbol.iterator` 方法，而**迭代器协议**指的是一个对象实现了`next`方法。注意：**一个对象可以同时实现可迭代协议和迭代器协议**。了解了这一点重写`entrirs`时我们就可以为此实现可迭代协议即解决`for...of`对其进行迭代而报错的问题。再是讨论了 `values`和`keys`方法，这两个方法重写实现非常相似，他们最大的区别就是后者不关心值的变化，只关心键的变化，因此在`track`追踪依赖时，**使用一个新的键`MAP_KEY_ITERATRE_KEY`新的`Symbol`类型 与之前的 `ITERATE_KEY` 收集的依赖区分开来。**这样在`SET`类型的操作时，不需要触发`MAP_KEY_ITERATRE_KEY`所关联的副作用函数，避免了不必要的更新，而`ADD`和`DELETE`类型操作发生时，将会触发`ITERATE_KEY`和`MAP_KEY_ITERATRE_KEY`相关副作用函数重新执行。

















