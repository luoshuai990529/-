# 第四章节：设计一个完善的响应系统

小结：

 1.  之前实现了一个简易的响应系统，我们完善了存储副作用函数'桶'的结构，解决了effect函数嵌套 以及'代码分支'带来的一些问题。现在我们接着来完善该系统，这里作者提到了另一个问题**“如何避免无限递归循环”**，产生原因：

     ```javascript
     const data = {foo: 1};
     const obj = new Proxy(data, {...});
     effect(() => obj.foo++)
     ```

     上面代码中effect注册的副作用函数内部有一个自增操作 `obj.foo++`，这个操作会引起栈溢出，我们知道拆分来看就是`obj.foo = obj.foo + 1`，**根本原因：正是因为这个语句中即会读取`obj.foo`的值，又会设置`obj.foo`的值**。因此它的执行流程就是：首先读取foo,触发track操作，收集副作用函数到"桶中"，其后给值+1会触发trigger操作，即将“桶”中的副作用函数取出执行。问题就是：这个副作用函数正在执行，但还没有执行完毕，就要开始下一次的执行。因此就会无限递归调用自己，产生栈溢出。**解决方案：在trigger动作发生时增加守卫条件：如果trigger触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行。**关键代码即**利用`activeEffect`来判断 trigger触发执行的副作用函数和当前正在执行的副作用函数是否相同。**

 2. 调度执行：可调度执行时响应系统非常重要的特征。什么是可调度性：**指当trigger动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数及方式。**作者通过举例一段代码，为满足其需求我们需要去调整代码，那么我们如果想在不调整代码的情况下去实现这个需求，那么就需要响应式系统支持**调度**。接着我们为`effect`函数设计一个**选项参数options(对象)**,允许用户指定调度器：我们可以给该对象传入**`scheduler`调度函数**，同时在`effect`函数内部将options对象挂载到对应的副作用函数上。这时我们就可以在trigger函数中触发副作用函数重新执行时，可以直接调用用户传递的调度器scheduler函数，从而把控制器交给用户。在通过了调度器函数满足了改变副作用函数的执行顺序之后，接着思考如何通过其控制副作用函数的执行次数：接着举例了一个对象属性`const obj = new Proxy( {foo: 1}, {...} )`的连续自增操作，连续两次执行`obj.foo++`，在没有指定调度器的情况下，它会依次输出打印1,2,3，分析可知`obj.foo` 的值其实一定会从1自增到3，而2只是它的国度状态。如果我们只关系结果的话，那么打印三次操作是多余的，因此我们基于调度器来实现这个功能：

     ```javascript
     // 核心代码
     // 定义一个任务队列,利用Set结构的自动去重功能
     const jobQueue = new Set()
     // 使用 Promise.resolve() 创建一个promise实例，用它将一个任务添加到微任务队列
     const p = Promise.resolve()
     // 定义一个标志代表是否正在刷新队列
     let isFlushing = false
     function flushJob() {
     	// 如果队列正在刷新，则什么都不做
         if(isFlushing) return
         isFlushing = true // 设置为true 代表正在刷新
         //在微任务队列中刷新 jobQueue 队列
         p.then(() => {
         	jobQueue.forEach(job => job())
         }).finally(() => {
         	// 结束后重置 isFlushing
         	isFlushing = false
         })
     }
     
     effect(() => {...},{
     	scheduler(fn){
         	// 每次调度时，将副作用函数添加到jobQueue队列中
             jobQueue.add(fn);
             // 调用flushJob 刷新队列
             flushJob()
         }
     })
     obj.foo++
     obj.foo++
     ```
     
     上面整段代码的效果是：连续对`obj.foo`执行两次自增操作,即会同步且连续的执行两次`scheduler`调度函数,即同一个副作用函数会被`jobQueue.add(fn)`语句添加两次,但由于Set数据结构的去重能力，最终`jobQueue`中只会有一项即当前的副作用函数。而类似地`flushJob`也会同步的连续执行两次，但是由于`isFlushing`标志的存在，实际上`flushJob`函数在一个事件循环内只会执行一次，即微任务队列内执行一次。因此能实现我们期望的输出`1,3`。到此作者提到**这个功能和在Vue.js中连续多次修改响应式数据但只会触发一次更新类似，实际上Vue.js内部实现了一个更完善的调度器，思路与上介绍相同。**
