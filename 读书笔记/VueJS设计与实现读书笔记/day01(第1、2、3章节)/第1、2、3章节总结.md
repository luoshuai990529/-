# 《Vue.JS的设计与实现》day01读书笔记

### 第一章节（权衡的艺术: 如何权衡性能、灵活性、可维护性...）

总结：

1. 本章节介绍了**命令式**和**声明式**两种范式的差异，其中命令式更加关注过程，而声明式更加关注结果。这里举例了jQuery的命令式代码示例和Vue.js更关注结果的声明式代码示例，并且抛出了结论：**声明式代码的性能不优于命令式代码的性能。** 因为声明式代码比命令式代码会多出一步过程：更新DOM时需要找出前后的差异并只更新变化的地方。这一步过程最理想的情况是当其性能消耗为0时，声明式代码与命令式代码的性能相同，因此无法做到超越，**毕竟框架本身是封装了命令式代码才实现了面向用户的声明式。** 而正因为声明式的代码可维护性更强，让代码看上去更直观，因此开发Vue.js在采用声明式提升可维护性的同时，也要想办法让性能损失最小化 。

2. 在概述了以上的区别后，我们明确了 **声明式代码的更新性能 = 找出差异的性能消耗 + 直接修改的性能消耗** 。因此为了最小化找出差异的性能消耗，就有了所谓的**虚拟DOM** 出现。同时也提出 采用虚拟DOM的更新技术的性能**理论上**不可能比元素JS操作DOM更高(**因为我们很难写出绝对优化的命令式代码**)。这里还区分了原生JavaScript实际上指的是像`document.createElement`之类的DOM操作方法, 并不包含`innerHtml`。我们知道涉及DOM的运算要远比JavaScript层面的计算性能差，并给出了进行跑分结果参考，最后对比了`innerHtml`和虚拟DOM在**创建页面时的性能** ：

   - `innerHtml`创建页面的性能: **HTML字符串拼接的计算量 + innerHTML的DOM计算量** 
   - 虚拟DOM创建页面的性能: **创建JavaScript对象(VNode)的计算量 + 创建真实DOM的计算量**

   ​
   讨论完创建页面时的性能情况，再讨论了更新页面时的过程：

   - `innerHtml`更新页面的过程：**重新构建HTML字符串，再重新设置DOM元素的innerHTML属性**，即哪怕是改了一个字，也要重新设置innerHTML属性。重新设置属性就等价于**销毁所有旧的DOM元素，再全量创建新的DOM元素**。
   - 虚拟DOM更新页面的过程：**创建新的JavaScript对象(虚拟DOM树)，在比较新旧DOM(Diff),再找到变化的元素并更新它**

   因此发现，影响虚拟DOM的性能因素和影响innerHTML的性能因素不同。对于虚拟DOM来说，无论页面多大都只会更新变化的内容，而对于innerHTML来说，页面越大，就意味着性能消耗越大。

   小结：性能差异高 => 低：原生JavaScript(指createElement等方法) > 虚拟DOM > innerHTML(模板)

3. 接着举例了 纯**运行时**(不够灵活)、纯**编译时**(如Svelte，性能更好但有损灵活性)、以及**运行时+编译时**结合(如Vue.js，保持灵活性的基础上尽可能的去优化) 框架的特点。



### 第二章节（框架设计的核心要素: 错误处理、构建产物...）

总结：

1. 首先介绍了Vue3中如何去提升用户的开发体验：错误提醒帮助开发者快速定位一些问题(console.warn())、提升调试时的体验(谷歌设置DevTools 勾选Console => Enable custom formatters)
2. 介绍了如何去控制代码的体积：使用rollup对项目进行构建时 通过插件(类似于webpack的DefinePlugin)预定义DEV常量，从而有的代码能配合**\_\_DEV\_\_ ** 常量的检查, 做到构建用于开发环境时 将常量设置为true，而让我们想提升开发体验的代码生效，而当构建用于生产环境的时候就将常量设置为false，因此生产环境的打包后的代码是不会出现为了提升开发体验的代码的，从而减少了生产环境的代码体积。
3. 如何做到良好的Tree-Shaking：想要实现Tree-Shaking，就要满足 **其模块必须是ESM（ES Module）**，因为**Tree-Shaking依赖ESM的静态结构**。还提到了通过注释：`/*#__PURE__*/` 的作用，告诉构建工具：对于该函数不会产生副作用，可以放心的对其Tree-Shaking。
4. 应该输出怎样的构建产物：上文提到了会基于 开发环境和 生成环境输出不同的包，实际上除了环境上的区分以外，还会根据使用场景的不同而输出其他形式的产物：如输出可以直接在HTML页面中script标签引入的IIFE格式的资源；因为浏览器对原生ESM的支持不错因此还输出ESM格式的资源(vue.esm-browser.js),其次这里还会输出一份vue.esm-bundler.js 供rollup或者webpack打包工具使用,这是因为构建提供给打包工具的ESM格式资源不能直接把\_\_DEV\_\_ 常量设置为true或者false，而要使用 process.env.NODE_ENV !== 'prod' 来做到Tree-Shaking；除此之外还希望用户可以在Node环境中通过require语句引入，即为了满足服务端渲染的需求，所以还会输出CJS的资源。
5. 特性开关：这里还提到了用户可以使用`__VUE_OPTIONS_API__`开关来关闭该特性(兼容Vue2的功能)从而减小资源的体积。
6. 错误处理能力：介绍了Vue.JS的错误处理原理，通过巧妙地`registerErrorHandler` 函数注册错误处理程序，然后在`callWithErrorHandling` 函数内部捕获错误，将其传递给用户注册的错误处理程序。从而让用户控制错误的处理使得代码变得简洁健壮。
7. 接着提到了Typescript的支持性，并点出了常见的误区：**使用TS编写代码与对TS类型支持友好其实是两码事**，为了让框架提供更友好的类型支持，往往要话费比实现框架功能本身更多的时间和精力。



### 第三章节（Vue3的设计思路、工作机制及重要组成部分介绍）

总结：这一章从全局的视角了解Vue3的设计思路、工作机制和其重要的组成部分。

1. 声明式的描述UI：讲述了使用**模板**的形式来描述UI，还可以使用JavaScript对象来描述UI(即**虚拟DOM**描述UI)；并提到了`h`函数,其返回值就是一个对象，作用是让我们编写虚拟DOM变得更轻松，因此该函数就是一个辅助创建虚拟DOM的工具函数而已。
2. 初步介绍渲染器，渲染器的作用就是**把虚拟DOM渲染成为真实DOM**，作者通过代码示例描述了如何编写一个**渲染器renderer函数**将一段虚拟DOM渲染成真实DOM，其实现思路分为三步：1.创建元素 2.为元素添加事件和属性(遍历vnode.props对象) 3.处理children(如果是数组就递归调用renderer)。 当然这也都只是创建节点，精髓之处都在更新节点的阶段。
3. 组件的本质：**组件就是一组DOM元素的封装**，这组DOM元素就是组件要渲染的内容。这里作者又通过定义了一个函数来代表组件的代码示例，接着引申出定义了一个JavaScript对象来表达组件，再对其renderer渲染器进行修改调整从而满足使用JavaScript对象表达组件的方式。表明了：**Vue中有状态的组件其实就是使用对象结构来表达的**。
4. 模板的工作原理：介绍完了虚拟DOM如何渲染成真实DOM之后，接着提到了模板时如何工作的，这里介绍了Vue.js框架中的另一个重要组成部分：**编译器**。其作用就是**将模板编译成渲染函数**，然后**渲染器**再把渲染函数返回的虚拟DOM渲染为真实DOM，这就是模板的工作原理，也是Vue.js的渲染页面的流程。
5. Vue.js是各个模块组成的有机整体，组建的实现依赖于渲染器，模板的编译依赖于编译器，并且编译后的代码是根据渲染器和虚拟DOM的设计决定的，因此Vue中的各个模块之间时互相关联和制约的。这里以编译器和渲染器两个关键的模块为例子简述了他们如何配合工作进行性能提升：**即在编译器进行编译成渲染函数的阶段，生成的虚拟DOM会多出一些属性，而这些属性标识恰恰可以告诉渲染器哪些属性(class、tag...)是动态变化的，因此渲染器就省去了查询变更节点的工作量，性能自然就提升了。**