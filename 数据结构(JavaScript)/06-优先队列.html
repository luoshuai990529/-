<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>



    <script>
        /* 
            一般情况下，从队列中删除的元素，一定是率先入队的元素。
            但是也有一些使用队列的应用，在删除元素的时候不需要遵守先进先出的约定。
            这种应用，就需要使用一个叫优先队列的数据结构

            从优先队列中删除元素的时候就需要优先考虑优先权，
            高优先级的先与低优先级的代码进行处理
        */



        function Queue() {
            this.dataStore = [];
            this.enqueue = enqueue;
            this.dequeue = dequeue;
            this.front = front;
            this.back = back;
            this.toString = toString;
            this.empty = empty;
        }
        // enqueue方法向队尾添加一个元素
        function enqueue(element) {
            this.dataStore.push(element);
        }
        // dequeue方法删除队首的元素
        // function dequeue() {
        //     return this.dataStore.shift();
        // }
        // 使用如下方法读取队首和队尾的元素
        function front() {
            return this.dataStore[0];
        }

        function back() {
            return this.dataStore[this.dataStore.length - 1];
        }
        // 使用toString方法显示队列内的所有元素
        // function toString() {
        //     let reStr = '';
        //     for (const r of this.dataStore) {
        //         reStr += r + "\n";
        //     }
        //     return reStr;
        // }
        // 最后定义一个方法判断队列是否为空
        function empty() {
            if (this.dataStore.length == 0) {
                return true;
            } else {
                return false;
            };
        }


        // 定义一个存储队列元素的对象，表示患者的优先级
        // code是一个整数，表示患者的优先级
        class Patient {
            constructor(name, code) {
                this.name = name;
                this.code = code;
            }
        }

        // 对dequeue方法进行改写：删除队列中拥有最高优先级的元素(code值越小优先级就越高)
        // 遍历寻找出code最小的值  即优先级最高的元素 然后返回删除的元素
        function dequeue() {
            let entry = 0;
            this.dataStore.forEach((items, index) => {
                if (items.code < this.dataStore[entry].code) {
                    entry = index;
                }
            })
            return this.dataStore.splice(entry, 1);
        }

        // 重新定义toString方法显示Patient对象
        function toString() {
            let retStr = "";
            this.dataStore.forEach((value) => {
                retStr += value.name + "---code:" + value.code + "\n";
            })
            return retStr;
        }

        // 测试这个优先队列
        let p1 = new Patient("史密斯1", 5);
        let p2 = new Patient("史密斯2", 2);
        let p3 = new Patient("史密斯3", 1);
        let p4 = new Patient("史密斯4", 4);
        let p5 = new Patient("史密斯5", 4);
        let p6 = new Patient("史密斯6", 2);

        let q = new Queue();
        q.enqueue(p1)
        q.enqueue(p2)
        q.enqueue(p3)
        q.enqueue(p4)
        q.enqueue(p5)
        q.enqueue(p6)
        console.log(q);
        console.log(q.toString());

        // 第一次删除
        q.dequeue()
        console.log(q.toString());
        // 第二次删除
        q.dequeue()
        console.log(q.toString());
        // 第三次删除
        q.dequeue()
        console.log(q.toString());
        // 第四次删除
        q.dequeue()
        console.log(q.toString());
        // 第五次删除
        q.dequeue()
        console.log(q.toString());
        // 第六次删除
        q.dequeue()
        console.log(q.toString());
    </script>
</body>

</html>