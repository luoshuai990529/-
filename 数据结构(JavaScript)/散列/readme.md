<!--
 * @Description: 散列
 * @Date: 2022-01-07 16:41:41
 * @Author: luoshuai
 * @LastEditors: luoshuai
 * @LastEditTime: 2022-01-07 16:41:41
     -->

## 散列

### 1-认识散列表

散列使用的数据结构叫做**散列表（Hash Table）**也有人叫**哈希表(Hash表)** 

**优点：** 在散列表上插入、删除、取数据 都非常快

**缺点：**查找操作效率低下，如查询一组数据中的最大值和最小值。

通过一个示例来学习散列思想：

> 示例：有89名学生选手参加校运会，那么每一个选手都需要有一个自己的编号，这89名选手的编号依次是1-89。我们希望用编程实现这样一个功能，可以通过编号快速的查找到对应选手的信息，我们可以把这89名选手的信息用一个**数组**来存储,即编号为1的选手就放到数组下标为1的位置；编号为2的选手就放到对应数组下标为2的位置。以此类推，这样我们如果想要查询编号为n的选手信息的话，我们可以直接通过下标n找到这名选手的信息即可，时间复杂度就是O(1)。这里其实就已经用到了散列的思想，但是这个例子还不够明显，那么我们可以进一步改造这个例子。
>
> 假设校长说参赛编号不能这么简单，要加上年级、班级等信息，所以我们可以把编号的规则稍作改造，比如 051127，前两位05表示年级，中间的11表示班级，最后的27还是表示选手的1-89的编号。这个时候我们该如何存储选手的信息呢，我们虽然不能直接吧编号作为选手的下标，但是我们可以截取编号的后两位作为数组的下标来存储选手的信息，这样子当通过参赛选手的编号来查询选手信息的时候，我们也用同样的方法来读取数组中的数据。
>
> 上面这个改造过的例子就是典型的散列思想。参赛选手的编号我们叫做**键(Key)** 或者关键字。我们用它来标识一个选手。我们把参赛选手编号转化为数组下标的映射方法就叫做**散列函数(或者Hash函数)**而这个散列函数计算得到的值就叫做**散列值(或者hash值)**

散列表是根据数组进行设计的，数组的长度是预先设定的，在通过一个**散列函数**将键映射为一个数字，这个数字的范围是0到散列表的长度。理想情况下，散列函数会将每一个键值映射为一个唯一的数组索引。即一个散列函数应该会满足下列条件：

1. 散列函数计算的值必须为非负整数
2. 如果key1 === key2,那么 hash(key1) === hash(key2) 
3. 如果key1 !== key2, 那么 hash(key1) !== hash(key2)

上述的第三种情况属于理论上的，因为真是情况下几乎不存在每个不同的key都对应不同的散列值，即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这种现象称为**散列冲突(碰撞)**

**通过示例代码来观察散列冲突**：01-散列表(HashTable类).html

##### 小结规律：

​	**散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。**

### 2-如何避免散列冲突(碰撞)

1. **开链法**

   开链法是指实现散列表的底层数组中，每个数组元素又是一个新的数据结构，如果每一个数组的元素又是另一个数组，这样它就可以存储多个键了。使用这种技术，即使两个键散列后的值相同，依然被保存在同样的位置。只不过在第二个数组中的位置不一样而已。图例：

   ![开链法](./images/kailianfa.png)



2. **线性探测法**

   线性探测法属于一种更一般化的散列技术：**开放寻址散列**。当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空就将数据存入该位置；如果不为空，则继续检查下一个位置，知道找到一个空的位置为止。

   ​

> **两种方法小结：**
>
> ​	当存储数据使用的数组特别大时，选择线性探测法要比开链法好。这里有一个公式，常常可以帮助我们选择使用哪种碰撞解决办法：如果数组的大小是待存储数据个数的 1.5 倍，那么使用开链法；如果数组的大小是待存储数据的两倍及两倍以上时，那么使用线性探测法。
>
> 更多或具体代码实现可以看到《数据结构与算法JavaScript描述》