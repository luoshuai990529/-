<!--
 * @Date: 2022-01-09 22:04:08
 * @LastEditors: Lewis
 * @LastEditTime: 2022-01-12 00:51:21
-->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <script src="./HashTable.js"></script>
        <script>
            const someNames = [
                "David",
                "Jennifer",
                "Donnie",
                "Raymond",
                "Cynthia",
                "Mike",
                "Clayton",
                "Danny",
                "Jonathan",
            ];
            // 01-测试HashTable类
            const hashTable = new HashTable();
            someNames.forEach((item) => {
                hashTable.put(item);
            });
            // 打印
            hashTable.showDistro();
            /* 
              打印测试发现，我们存储的数据并不均匀
              Cynthia
              Clayton
              Donnie
              David
              Danny
              Mike
              Jennifer
              Jonathan

              在插入时的打印：
              Hash value: David -> 488
              Hash value: Jennifer -> 817
              Hash value: Donnie -> 605
              Hash value: Raymond -> 730
              Hash value: Cynthia -> 720
              Hash value: Mike -> 390
              Hash value: Clayton -> 730
              Hash value: Danny -> 506
              Hash value: Jonathan -> 819

              我们打印插入时的散列值，发现字符串 "Clayton" 和 "Raymond" 的散列值是一样的，因此引发了碰撞，只有 "Clayton" 存入了散列表
            */


            /* 
              02-一个更好的散列函数：
                
              为了避免散列冲突(碰撞),首先要确保散列表中用来存储数据的数组其大小是个质数（关键）。
              这和计算散列值时使用的取余运算有关。数组的长度应该在100以上，这是为了让数据在散列表中分布的更均匀。
              
              为了避免碰撞，在给散列表一个合适的大小后，接下来要有一个计算散列值的更好方法。
              纳算霍法很好地解决了这个问题。
            */
        </script>
    </body>
</html>
